<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Engine v2026.01.17-06</title>
    <style>
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(2, 2, 10, 0.95); z-index: 100;
        }
        .mode-btn {
            padding: 15px 30px; background: #111; color: #00d4ff; 
            border: 2px solid #00d4ff; border-radius: 8px; cursor: pointer;
        }
        #monitor {
            position: absolute; top: 15px; left: 15px; font-size: 11px;
            background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px;
            border: 1px solid #333; pointer-events: none;
        }
        #ver-tag { position: absolute; bottom: 5px; right: 5px; font-size: 9px; color: #333; }
    </style>
</head>
<body>

<div id="overlay">
    <h2 style="letter-spacing: 2px;">SMOOTH LOG ENGINE v6</h2>
    <button class="mode-btn" onclick="startMic()">START MIC MODE</button>
</div>

<div id="monitor">
    <div style="color: #00d4ff;">INTERPOLATION: ACTIVE</div>
    STATUS: SMOOTHING LOW-BINS
</div>

<div id="ver-tag">ENGINE_ID: 2026.01.17-06</div>
<canvas id="waveCanvas"></canvas>

<script>
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d');
let audioCtx, analyser, dataArray, sourceNode;
let isRunning = false;

async function startMic() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    sourceNode = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024; // 高解像度解析
    sourceNode.connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    document.getElementById('overlay').style.display = 'none';
    isRunning = true;
    resize();
    animate();
}

// A特性補正
function getAWeighting(f) {
    if (f <= 0) return -100;
    const f2 = f * f;
    const rA = (12194 * 12194 * f2 * f2) / 
               ((f2 + 20.6*20.6) * Math.sqrt((f2 + 107.7*107.7) * (f2 + 737.9*737.9)) * (f2 + 12194*12194));
    return 2.0 + 20 * Math.log10(rA);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function animate() {
    if (!isRunning) return;
    requestAnimationFrame(animate);
    analyser.getByteFrequencyData(dataArray);

    ctx.fillStyle = 'rgba(2, 2, 10, 0.25)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const barCount = Math.floor(canvas.width / 3);
    const baseY = canvas.height * 0.65;
    const sampleRate = audioCtx.sampleRate;

    ctx.globalCompositeOperation = 'lighter';

    for (let i = 0; i < barCount; i++) {
        const relX = i / barCount;
        
        // --- 改良版: 対数インデックスの補間 ---
        const minIdx = 1;
        const maxIdx = dataArray.length * 0.85;
        const logIdxExact = minIdx * Math.pow(maxIdx / minIdx, relX);
        
        const idxBase = Math.floor(logIdxExact);
        const fraction = logIdxExact - idxBase;
        
        // 隣り合う2つのbinから値を読み取って補間
        const v1 = dataArray[idxBase];
        const v2 = dataArray[idxBase + 1] || v1;
        const val = v1 * (1 - fraction) + v2 * fraction;

        const freq = (logIdxExact * sampleRate) / (analyser.fftSize);
        const weight = getAWeighting(freq);
        let perceivedVal = Math.max(0, val + weight);

        const h = (perceivedVal / 255) * canvas.height * 0.7 * Math.sin(relX * Math.PI) + 2;
        const x = i * 3;
        const hue = 280 + (30 - 280) * relX;

        const grd = ctx.createLinearGradient(x, baseY - h, x, baseY);
        grd.addColorStop(0, `hsla(${hue}, 100%, 75%, 0.8)`);
        grd.addColorStop(1, `hsla(${hue}, 80%, 30%, 0)`);
        ctx.fillStyle = grd;
        ctx.fillRect(x, baseY - h, 2, h);
    }
}
window.addEventListener('resize', resize);
</script>
</body>
</html>
