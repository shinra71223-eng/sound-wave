<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAW Analyzer v11</title>
    <style>
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 5, 0.95); z-index: 100;
        }
        .mode-btn {
            padding: 15px 40px; background: transparent; color: #00f2fe; 
            border: 2px solid #00f2fe; border-radius: 50px; cursor: pointer; font-weight: bold;
            font-size: 16px; box-shadow: 0 0 15px rgba(0, 242, 254, 0.2);
        }
        #monitor {
            position: absolute; top: 10px; left: 10px; font-size: 10px; color: #444;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="overlay">
    <button class="mode-btn" onclick="startMic()">START ANALYZER</button>
</div>

<div id="monitor">RAW_MODE: 16384 FFT / A-WEIGHTED</div>

<canvas id="waveCanvas"></canvas>

<script>
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d');
let audioCtx, analyser, dataArray, sourceNode;
let isRunning = false;
let barMapping = [];

async function startMic() {
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        sourceNode = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 16384; 
        analyser.smoothingTimeConstant = 0.65; 
        sourceNode.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        document.getElementById('overlay').style.display = 'none';
        isRunning = true;
        resize();
        animate();
    } catch (err) { alert("Mic Error: " + err); }
}

function getAWeighting(f) {
    if (f <= 20) return -50;
    const f2 = f * f;
    const rA = (12194 ** 2 * f2 ** 2) / ((f2 + 20.6 ** 2) * Math.sqrt((f2 + 107.7 ** 2) * (f2 + 737.9 ** 2)) * (f2 + 12194 ** 2));
    return 20 * Math.log10(rA) + 2.0;
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const barWidth = 3;
    const barCount = Math.floor(canvas.width / barWidth);
    const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
    const minFreq = 20, maxFreq = (sampleRate / 2) * 0.7;
    
    barMapping = [];
    for (let i = 0; i < barCount; i++) {
        const f = minFreq * Math.pow(maxFreq / minFreq, i / barCount);
        const binIdx = Math.round((f * 16384) / sampleRate);
        const hue = 280 + (30 - 280) * (i / barCount);
        barMapping.push({ binIdx, weight: getAWeighting(f), x: i * barWidth, color: `hsla(${hue}, 100%, 75%, 0.8)` });
    }
}

function animate() {
    if (!isRunning) return;
    requestAnimationFrame(animate);
    analyser.getByteFrequencyData(dataArray);

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0, 0, 8, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const baseY = canvas.height * 0.7;
    ctx.globalCompositeOperation = 'lighter';

    for (let i = 0; i < barMapping.length; i++) {
        const m = barMapping[i];
        const val = dataArray[m.binIdx] || 0;
        // 日常音の微細な変化を見やすくするため、増幅率を0.8に微増
        const h = Math.max(2, (val + m.weight) / 255 * canvas.height * 0.8 * Math.sin((i / barMapping.length) * Math.PI));
        ctx.fillStyle = m.color;
        ctx.fillRect(m.x, baseY - h, 2, h);
    }
}
window.addEventListener('resize', resize);
</script>
</body>
</html>
