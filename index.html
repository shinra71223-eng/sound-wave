<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Analyzer v12</title>
    <style>
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle, #1a1a2e 0%, #000 100%); z-index: 100; transition: 0.8s;
        }
        .start-btn {
            padding: 20px 50px; font-size: 18px; color: #00f2fe; background: transparent;
            border: 2px solid #00f2fe; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.3); transition: 0.3s;
        }
        .start-btn:hover { background: #00f2fe; color: #000; }

        /* ダッシュボード */
        #dashboard {
            position: absolute; bottom: -100px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 500px; background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px 20px 0 0; padding: 15px; transition: 0.5s; z-index: 50;
            display: flex; flex-direction: column; gap: 10px;
        }
        #dashboard.active { bottom: 0; }
        .tab-handle {
            position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
            background: rgba(10, 10, 20, 0.85); padding: 5px 20px; border-radius: 10px 10px 0 0;
            font-size: 10px; color: #00f2fe; cursor: pointer;
        }
        .mode-row { display: flex; justify-content: space-around; gap: 10px; }
        .mode-btn {
            flex: 1; padding: 8px; font-size: 11px; background: #222; border: 1px solid #444;
            color: #ccc; border-radius: 5px; cursor: pointer;
        }
        .mode-btn.active { border-color: #00f2fe; color: #00f2fe; background: rgba(0, 242, 254, 0.1); }
        .slider-row { display: flex; align-items: center; gap: 10px; font-size: 11px; color: #888; }
        input[type="range"] { flex: 1; accent-color: #00f2fe; }
    </style>
</head>
<body>

<div id="overlay">
    <button class="start-btn" onclick="startApp()">START VISUALIZER v12</button>
</div>

<div id="dashboard">
    <div class="tab-handle" onclick="toggleDash()">DASHBOARD ▲</div>
    <div class="mode-row">
        <button id="btn-art" class="mode-btn active" onclick="setMode('ART')">ART</button>
        <button id="btn-raw" class="mode-btn" onclick="setMode('RAW')">RAW</button>
        <button id="btn-voice" class="mode-btn" onclick="setMode('VOICE')">VOICE</button>
    </div>
    <div class="slider-row">
        SENSITIVITY <input type="range" id="sensSlider" min="0.1" max="5.0" step="0.1" value="1.5">
    </div>
    <div class="slider-row" style="justify-content: center; font-size: 9px;">
        AUTO-GAIN: <span id="autoGainVal">1.0</span>x / <span id="currentPeak">0</span>
    </div>
</div>

<canvas id="waveCanvas"></canvas>

<script>
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d');
let audioCtx, analyser, dataArray, sourceNode;
let isRunning = false;
let currentMode = 'ART';
let barMapping = [];
let maxVolume = 1; // オートゲイン用

function toggleDash() { document.getElementById('dashboard').classList.toggle('active'); }

function setMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-' + mode.toLowerCase()).classList.add('active');
    setupMapping();
}

async function startApp() {
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        sourceNode = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 8192; // 安定性と解像度のバランス
        analyser.smoothingTimeConstant = 0.75;
        sourceNode.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => document.getElementById('overlay').style.display = 'none', 800);
        isRunning = true;
        resize();
        animate();
    } catch (err) { alert("Mic Error: " + err); }
}

function getAWeighting(f) {
    if (f <= 20) return -50;
    const f2 = f * f;
    const rA = (12194 ** 2 * f2 ** 2) / ((f2 + 20.6 ** 2) * Math.sqrt((f2 + 107.7 ** 2) * (f2 + 737.9 ** 2)) * (f2 + 12194 ** 2));
    return 20 * Math.log10(rA) + 2.0;
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    setupMapping();
}

function setupMapping() {
    barMapping = [];
    const barWidth = 3;
    const barCount = Math.floor(canvas.width / barWidth);
    const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
    const minFreq = 20;
    const maxFreq = (sampleRate / 2) * 0.7;

    for (let i = 0; i < barCount; i++) {
        const relX = i / barCount;
        const f = minFreq * Math.pow(maxFreq / minFreq, relX);
        const binIdx = Math.round((f * 8192) / sampleRate);
        const hue = 280 + (30 - 280) * relX;
        barMapping.push({ binIdx, weight: getAWeighting(f), x: i * barWidth, hue });
    }
}

function animate() {
    if (!isRunning) return;
    requestAnimationFrame(animate);
    analyser.getByteFrequencyData(dataArray);

    // --- オートゲイン・ロジック ---
    let frameMax = 0;
    for(let i=0; i<dataArray.length; i++) if(dataArray[i] > frameMax) frameMax = dataArray[i];
    // 徐々にピークを減衰させることで環境の変化に追従
    maxVolume = Math.max(frameMax, maxVolume * 0.995, 10); 
    const autoGain = 200 / maxVolume; 
    document.getElementById('autoGainVal').innerText = autoGain.toFixed(1);
    document.getElementById('currentPeak').innerText = frameMax;

    // 背景（残像）
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0, 0, 8, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const baseY = canvas.height * 0.7;
    const userSens = parseFloat(document.getElementById('sensSlider').value);

    for (let i = 0; i < barMapping.length; i++) {
        const m = barMapping[i];
        let val = dataArray[m.binIdx] || 0;

        // モードによる補正
        let h;
        if (currentMode === 'RAW') {
            h = (val / 255) * canvas.height * 0.6 * userSens;
        } else {
            // ART/VOICEモード: 聴感補正 + オートゲイン
            let pVal = Math.max(0, (val + m.weight) * autoGain);
            h = (pVal / 255) * canvas.height * 0.6 * userSens * Math.sin((i / barMapping.length) * Math.PI);
        }

        // --- 描画 (美しさの追求) ---
        ctx.globalCompositeOperation = 'lighter';
        
        // 1. メインの光の柱
        const grd = ctx.createLinearGradient(m.x, baseY - h, m.x, baseY);
        grd.addColorStop(0, `hsla(${m.hue}, 100%, 80%, 0.9)`);
        grd.addColorStop(1, `hsla(${m.hue}, 80%, 40%, 0)`);
        ctx.fillStyle = grd;
        ctx.fillRect(m.x, baseY - h, 2, h);

        if (currentMode === 'ART' && h > 10) {
            // 2. 先端のグロー（輝き）
            ctx.fillStyle = `hsla(${m.hue}, 100%, 90%, 0.5)`;
            ctx.beginPath();
            ctx.arc(m.x + 1, baseY - h, 2, 0, Math.PI * 2);
            ctx.fill();

            // 3. 床の反射
            ctx.fillStyle = `hsla(${m.hue}, 100%, 50%, 0.15)`;
            ctx.fillRect(m.x, baseY + 5, 2, h * 0.3);
        }
