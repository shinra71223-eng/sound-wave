<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stellar Beam v16.6</title>
    <style>
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: #000; z-index: 100;
        }
        .start-btn {
            padding: 20px 50px; color: #fff; background: linear-gradient(45deg, #00f2fe, #7c3aed);
            border: none; border-radius: 50px; font-weight: bold; font-size: 16px; cursor: pointer;
        }
    </style>
</head>
<body>

<div id="overlay">
    <button id="startBtn" class="start-btn">IGNITE STELLAR BEAM</button>
</div>

<canvas id="waveCanvas"></canvas>

<script>
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let audioCtx, analyser, dataArray, isRunning = false;
let bands = [], charge = 0, flash = 0, shockwave = 0, rayLife = 0;

// パーティクル・プール
const MAX_P = 800;
const pPool = Array.from({ length: MAX_P }, () => ({ x:0, y:0, vx:0, vy:0, life:0, hue:0, active:false }));

// --- 調整用パラメータ (より厳格な爆発条件) ---
const INSTANT_LIMIT = 254;      // 瞬間爆発：ほぼ最高音量
const CHARGE_THRESHOLD = 85;    // 蓄積開始：かなり大きな音が必要 (以前の45から大幅UP)
const CRITICAL_POINT = 100;     // 臨界点
const CHARGE_RATE = 0.33;       // 約5秒間(300フレーム)の持続で爆発
const DECAY_RATE = 0.95;        // 放電：静かな時にエネルギーが抜ける速さ

function spawn(x, y, hue, vx, vy) {
    const p = pPool.find(p => !p.active) || pPool[0];
    p.active = true; p.x = x; p.y = y; p.vx = vx; p.vy = vy;
    p.life = 1.0; p.hue = hue;
}

document.getElementById('startBtn').onclick = async () => {
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        await audioCtx.resume();
        document.getElementById('overlay').style.display = 'none';
        isRunning = true; resize(); animate();
    } catch (err) { alert(err); }
};

function resize() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    setupBands();
}

function setupBands() {
    bands = [];
    const sampleRate = audioCtx ? audioCtx.sampleRate : 48000;
    let freq = 25;
    while (freq < 16000) {
        let nextFreq = freq * 1.25;
        bands.push({ start: Math.floor(freq * 2048 / sampleRate), end: Math.floor(nextFreq * 2048 / sampleRate), freq });
        freq = nextFreq;
    }
}

function explode(centerX, centerY) {
    flash = 1.0;
    shockwave = 10;
    rayLife = 1.0; // ビームの寿命をセット
    for (let i = 0; i < 400; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = Math.random() * 28 + 4;
        spawn(centerX, centerY, Math.random() * 60 + 200, Math.cos(ang) * spd, Math.sin(ang) * spd);
    }
}

function animate() {
    if (!isRunning) return;
    requestAnimationFrame(animate);
    analyser.getByteFrequencyData(dataArray);

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#000008';
    ctx.globalAlpha = 0.22;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1.0;

    const centerX = canvas.width / 2;
    const centerY = canvas.height * 0.45;
    
    let totalAmp = 0;
    let maxAmpInFrame = 0;
    ctx.globalCompositeOperation = 'lighter';

    bands.forEach((b, i) => {
        let peak = 0;
        for (let j = b.start; j <= b.end; j++) if (dataArray[j] > peak) peak = dataArray[j];
        if (peak > maxAmpInFrame) maxAmpInFrame = peak;
        let val = Math.max(0, peak - 18);
        totalAmp += val;

        const r = Math.pow((val / 255) * 15, 0.8) * canvas.width * 0.3;
        const hue = 260 + (i * 3);

        if (r > 10) {
            for (let s = 0; s < 6; s++) {
                const angle = s * (Math.PI/3) + (Date.now() * 0.0005);
                ctx.fillStyle = `hsla(${hue}, 100%, 70%, 0.12)`;
                ctx.beginPath(); ctx.arc(centerX + Math.cos(angle) * r, centerY + Math.sin(angle) * r, 2, 0, 7); ctx.fill();
            }
        }
    });

    // --- トリガー・ロジック調整 ---
    const avgAmp = totalAmp / bands.length;
    if (maxAmpInFrame >= INSTANT_LIMIT) {
        explode(centerX, centerY);
        charge = 0;
    } else if (avgAmp > CHARGE_THRESHOLD) {
        charge += CHARGE_RATE;
    } else {
        charge *= DECAY_RATE;
    }

    if (charge > CRITICAL_POINT) {
        explode(centerX, centerY);
        charge = 0;
    }

    // --- 一軸の超高輝度ビーム描画 ---
    if (rayLife > 0) {
        const rayH = 4 * rayLife; // 芯の太さ
        const glowH = 60 * rayLife; // 周囲の光の広がり
        
        // 横方向の超高輝度グラデーション
        const grad = ctx.createLinearGradient(0, centerY, canvas.width, centerY);
        grad.addColorStop(0, 'transparent');
        grad.addColorStop(0.5, `rgba(255, 255, 255, ${rayLife})`); // 中心は真っ白
        grad.addColorStop(1, 'transparent');
        
        // 周囲の淡い光
        ctx.fillStyle = `hsla(210, 100%, 70%, ${rayLife * 0.3})`;
        ctx.fillRect(0, centerY - glowH/2, canvas.width, glowH);
        
        // 鋭い芯の光
        ctx.fillStyle = grad;
        ctx.fillRect(0, centerY - rayH/2, canvas.width, rayH);
        
        rayLife -= 0.007; // 約2秒かけて消える
    }

    // 衝撃波
    if (shockwave > 0) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0, 1 - shockwave/canvas.width)})`;
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.arc(centerX, centerY, shockwave, 0, 7); ctx.stroke();
        shockwave += 35;
        if (shockwave > canvas.width * 1.5) shockwave = 0;
    }

    // フラッシュ
    if (flash > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${flash})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        flash *= 0.82;
    }

    // 蓄積コア
    if (charge > 5) {
        const size = (charge * 0.7);
        ctx.fillStyle = `hsla(190, 100%, 90%, ${charge/120})`;
        ctx.beginPath(); ctx.arc(centerX, centerY, size, 0, 7); ctx.fill();
    }

    // 粒子
    pPool.forEach(p => {
        if (!p.active) return;
        p.x += p.vx; p.y += p.vy; p.life -= 0.016;
        if (p.life <= 0) p.active = false;
        ctx.fillStyle = `hsla(${p.hue}, 100%, 85%, ${p.life})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, 7); ctx.fill();
    });
}
window.addEventListener('resize', resize);
</script>
</body>
</html>
